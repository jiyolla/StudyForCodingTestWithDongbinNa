import sys


def solve():
    read = sys.stdin.readline
    n = int(read())
    w = int(read())
    work = [list(map(int, read().split())) for _ in range(w)]
    # 자 생각을 해보자~
    # 순서대로, 주어진 지점들을 방문해야 하는데, 두 경찰차의 이동거리 합이 최소가 되게 한다라.
    # 경찰차가 한 대이면, 거리는 정해져 있고 흠
    # 매 지점을 어느 경찰차가 방문해야할지 정해야 되는데
    # 현재 위치도 물론 영향을 끼치지만, 그 후에 방문해야할 지점들도 영향을 끼친다.
    # 예를 들어서, 그 후에 방문해야할 지점 중에 현재 A경찰차의 위치와 매우 가깝다면,
    # A를 움직이는 것이 비효율적일 수도 있다는 게 보인다.
    # 분할 정복이 될까?
    # work[:i]는 work[:i - 1]만으로 풀 수 있나?
    # 뒤에 오는 지점에 의해서도 영향을 받는 거 같긴 한데
    # 아니 그냥, 저렇게 생각해보자.
    # work[:i]에 대한 답을 알고 있다고 해보자.
    # work[:i+1]를 풀 수 있는가?
    # work[:i]를 알고 있다면, 경찰차들의 마지막 위치들도 알 것이다.
    # 웅
    # work[:i]에서 work[i]를 추가로 푸는 것
    # work[:i-1]에서 work[i-1: i+1]를 푸는 것
    # 이런식으로 해야겠구먼
    # 그러면 상태값을 i,j로 정의해야겠네
    # work[i][j]는 i번부터 j번 일까지 처리하는 데 드는 최소 시간으로 하면 될 거 같은데
    # 이러면 시간 복잡도가 어떻게 되지?
    # work[1][w]를 구하기 위해서는
    # work[1][w-1]+work[w-1][w], work[1][w-2]+work[w-2][w], ..., work[1][2]+work[2][w]
    # 를 구해야 하고
    # 총 O(w^2)의 시간이 걸리는 거 같네
    # w가 1000이하니까 가능하긴 하네
    # dist[i][j]는 i번일부터 j번일까지 처리하는 데 최소로 이동하는 거리
    dist = [[] for _ in range(w)]
    # 아앙!! 근데 문제가 있다. 경찰차의 상태 정보도 들어가야 되네...
    # 아니 그러면, 경찰차의 상태 정보+처리해야 되는 일까지 다 상태 정보로 넣어버리면 너무 크지 않을까...
    # 한 경찰차 당 가능한 위치가 n^2가인데...가능한 일의 조합은 wC2이고...
    # 거의 전수 조사랑 같은 격이 될 거 같네
    # 브루트 포스로 하면 2^w이고 흠...
    # 아아아!!!!
    # 경찰차의 가능한 위치가 n^2이 아니여~, w개임 ㅋㅋㅋㅋ
    # 엄청난 발견이군
    # 정확히 말해서는 w ~ w+2임
    # 아 내가 초반에 괜히 경찰차 위치 정보를 뺀 게 아니군...
    # ㅇㅋ. 마지막으로 한번 정리해보자
    # dist[i][j]는 i번일부터 j번일까지 처리하는 데 이동하는 최소 거리이고
    # dist[1][w]를 구하는 게 목적인데
    # dist[i][j]는 min(dist[1][j-1] + dist[j-1][j], dist[1][j-2] + dist[j-2][j], ..., dist[1][2] + dist[2][j])이다
    # 바텀업으로 갈 것이냐 탑다운으로 갈 것이냐?는 거의 모든 subproblem을 해결해야 되냐에 달렸는데...
    # 흠...min을 구하려면 해야 되는 듯
    # 그럼 바텀업으로 가는데, 어떤식으로 올려야 착실히 쌓이지?
    # i - j를 기준으로 쌓으면 될 것 같다.
    # 즉, i - j가 작은 것부터 쌓으면, dist[i][j]를 구하는데 하위 문제가 아직 안 풀린 상황은 나타나지 않을 것 같다.
    for diff in range(1, w):
        for i in range(1, w - diff + 1):
            # dist[i][i + diff]를 구한다
    # 아 갑자기 또 머리 아프네..
    # 어느 차가 간다의 정보가 어디있지..?
    # 예를 들어서 dist[5][6]이라고 치면, 5번 일에서 6번일로 이동하는 데는 시간을 넣을텐데 음
    # 아, 차가 두 개가 있다는 건
    # 흠...5번에 차A가 있고, 차B는 2번에 있다고 치면, 아 미치겠네 ㅋㅋㅋㅋㅋ
    # 이거 아닌 거 같다...
    # 2번에서 7번 가는 방법의 정보를 어떻게 통합하지..
    # ㅈㄴ 어렵네 스벌.
    # 여기서 핵심적인 문제는 dist[i][j]를 구하는데, 
    # ㅠ.
    # 결국에는 답을 봐버렸다...
    # 이해 된 거 같은데 구현해보자.
    

solve()
